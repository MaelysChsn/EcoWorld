#include "pch-cpp.hpp"

#ifndef _MSC_VER
# include <alloca.h>
#else
# include <malloc.h>
#endif


#include <limits>
#include <stdint.h>






IL2CPP_EXTERN_C_BEGIN
IL2CPP_EXTERN_C_END

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Winvalid-offsetof"
#pragma clang diagnostic ignored "-Wunused-variable"
#endif

// <Module>
struct  U3CModuleU3E_tCDBFDDBC301C923DCA2D4CC77559453F9960E400 
{
public:

public:
};


// System.Object

struct Il2CppArrayBounds;

// System.Array


// System.ValueType
struct  ValueType_tDBF999C1B75C48C68621878250DBF6CDBCF51E52  : public RuntimeObject
{
public:

public:
};

// Native definition for P/Invoke marshalling of System.ValueType
struct ValueType_tDBF999C1B75C48C68621878250DBF6CDBCF51E52_marshaled_pinvoke
{
};
// Native definition for COM marshalling of System.ValueType
struct ValueType_tDBF999C1B75C48C68621878250DBF6CDBCF51E52_marshaled_com
{
};

// System.Single
struct  Single_tE07797BA3C98D4CA9B5A19413C19A76688AB899E 
{
public:
	// System.Single System.Single::m_value
	float ___m_value_0;

public:
	inline static int32_t get_offset_of_m_value_0() { return static_cast<int32_t>(offsetof(Single_tE07797BA3C98D4CA9B5A19413C19A76688AB899E, ___m_value_0)); }
	inline float get_m_value_0() const { return ___m_value_0; }
	inline float* get_address_of_m_value_0() { return &___m_value_0; }
	inline void set_m_value_0(float value)
	{
		___m_value_0 = value;
	}
};


// System.UInt32
struct  UInt32_tE60352A06233E4E69DD198BCC67142159F686B15 
{
public:
	// System.UInt32 System.UInt32::m_value
	uint32_t ___m_value_0;

public:
	inline static int32_t get_offset_of_m_value_0() { return static_cast<int32_t>(offsetof(UInt32_tE60352A06233E4E69DD198BCC67142159F686B15, ___m_value_0)); }
	inline uint32_t get_m_value_0() const { return ___m_value_0; }
	inline uint32_t* get_address_of_m_value_0() { return &___m_value_0; }
	inline void set_m_value_0(uint32_t value)
	{
		___m_value_0 = value;
	}
};


// emotitron.Compression.ByteConverter
struct  ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54 
{
public:
	union
	{
		#pragma pack(push, tp, 1)
		struct
		{
			// System.Single emotitron.Compression.ByteConverter::float32
			float ___float32_0;
		};
		#pragma pack(pop, tp)
		struct
		{
			float ___float32_0_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			// System.Double emotitron.Compression.ByteConverter::float64
			double ___float64_1;
		};
		#pragma pack(pop, tp)
		struct
		{
			double ___float64_1_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			// System.SByte emotitron.Compression.ByteConverter::int8
			int8_t ___int8_2;
		};
		#pragma pack(pop, tp)
		struct
		{
			int8_t ___int8_2_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			// System.Int16 emotitron.Compression.ByteConverter::int16
			int16_t ___int16_3;
		};
		#pragma pack(pop, tp)
		struct
		{
			int16_t ___int16_3_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			// System.UInt16 emotitron.Compression.ByteConverter::uint16
			uint16_t ___uint16_4;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint16_t ___uint16_4_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			// System.Char emotitron.Compression.ByteConverter::character
			Il2CppChar ___character_5;
		};
		#pragma pack(pop, tp)
		struct
		{
			Il2CppChar ___character_5_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			// System.Int32 emotitron.Compression.ByteConverter::int32
			int32_t ___int32_6;
		};
		#pragma pack(pop, tp)
		struct
		{
			int32_t ___int32_6_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			// System.UInt32 emotitron.Compression.ByteConverter::uint32
			uint32_t ___uint32_7;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint32_t ___uint32_7_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			// System.Int64 emotitron.Compression.ByteConverter::int64
			int64_t ___int64_8;
		};
		#pragma pack(pop, tp)
		struct
		{
			int64_t ___int64_8_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			// System.UInt64 emotitron.Compression.ByteConverter::uint64
			uint64_t ___uint64_9;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint64_t ___uint64_9_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			// System.Byte emotitron.Compression.ByteConverter::byte0
			uint8_t ___byte0_10;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint8_t ___byte0_10_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte1_11_OffsetPadding[1];
			// System.Byte emotitron.Compression.ByteConverter::byte1
			uint8_t ___byte1_11;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte1_11_OffsetPadding_forAlignmentOnly[1];
			uint8_t ___byte1_11_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte2_12_OffsetPadding[2];
			// System.Byte emotitron.Compression.ByteConverter::byte2
			uint8_t ___byte2_12;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte2_12_OffsetPadding_forAlignmentOnly[2];
			uint8_t ___byte2_12_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte3_13_OffsetPadding[3];
			// System.Byte emotitron.Compression.ByteConverter::byte3
			uint8_t ___byte3_13;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte3_13_OffsetPadding_forAlignmentOnly[3];
			uint8_t ___byte3_13_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte4_14_OffsetPadding[4];
			// System.Byte emotitron.Compression.ByteConverter::byte4
			uint8_t ___byte4_14;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte4_14_OffsetPadding_forAlignmentOnly[4];
			uint8_t ___byte4_14_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte5_15_OffsetPadding[5];
			// System.Byte emotitron.Compression.ByteConverter::byte5
			uint8_t ___byte5_15;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte5_15_OffsetPadding_forAlignmentOnly[5];
			uint8_t ___byte5_15_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte6_16_OffsetPadding[6];
			// System.Byte emotitron.Compression.ByteConverter::byte6
			uint8_t ___byte6_16;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte6_16_OffsetPadding_forAlignmentOnly[6];
			uint8_t ___byte6_16_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte7_17_OffsetPadding[7];
			// System.Byte emotitron.Compression.ByteConverter::byte7
			uint8_t ___byte7_17;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte7_17_OffsetPadding_forAlignmentOnly[7];
			uint8_t ___byte7_17_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___uint16_B_18_OffsetPadding[4];
			// System.UInt32 emotitron.Compression.ByteConverter::uint16_B
			uint32_t ___uint16_B_18;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___uint16_B_18_OffsetPadding_forAlignmentOnly[4];
			uint32_t ___uint16_B_18_forAlignmentOnly;
		};
	};

public:
	inline static int32_t get_offset_of_float32_0() { return static_cast<int32_t>(offsetof(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54, ___float32_0)); }
	inline float get_float32_0() const { return ___float32_0; }
	inline float* get_address_of_float32_0() { return &___float32_0; }
	inline void set_float32_0(float value)
	{
		___float32_0 = value;
	}

	inline static int32_t get_offset_of_float64_1() { return static_cast<int32_t>(offsetof(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54, ___float64_1)); }
	inline double get_float64_1() const { return ___float64_1; }
	inline double* get_address_of_float64_1() { return &___float64_1; }
	inline void set_float64_1(double value)
	{
		___float64_1 = value;
	}

	inline static int32_t get_offset_of_int8_2() { return static_cast<int32_t>(offsetof(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54, ___int8_2)); }
	inline int8_t get_int8_2() const { return ___int8_2; }
	inline int8_t* get_address_of_int8_2() { return &___int8_2; }
	inline void set_int8_2(int8_t value)
	{
		___int8_2 = value;
	}

	inline static int32_t get_offset_of_int16_3() { return static_cast<int32_t>(offsetof(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54, ___int16_3)); }
	inline int16_t get_int16_3() const { return ___int16_3; }
	inline int16_t* get_address_of_int16_3() { return &___int16_3; }
	inline void set_int16_3(int16_t value)
	{
		___int16_3 = value;
	}

	inline static int32_t get_offset_of_uint16_4() { return static_cast<int32_t>(offsetof(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54, ___uint16_4)); }
	inline uint16_t get_uint16_4() const { return ___uint16_4; }
	inline uint16_t* get_address_of_uint16_4() { return &___uint16_4; }
	inline void set_uint16_4(uint16_t value)
	{
		___uint16_4 = value;
	}

	inline static int32_t get_offset_of_character_5() { return static_cast<int32_t>(offsetof(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54, ___character_5)); }
	inline Il2CppChar get_character_5() const { return ___character_5; }
	inline Il2CppChar* get_address_of_character_5() { return &___character_5; }
	inline void set_character_5(Il2CppChar value)
	{
		___character_5 = value;
	}

	inline static int32_t get_offset_of_int32_6() { return static_cast<int32_t>(offsetof(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54, ___int32_6)); }
	inline int32_t get_int32_6() const { return ___int32_6; }
	inline int32_t* get_address_of_int32_6() { return &___int32_6; }
	inline void set_int32_6(int32_t value)
	{
		___int32_6 = value;
	}

	inline static int32_t get_offset_of_uint32_7() { return static_cast<int32_t>(offsetof(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54, ___uint32_7)); }
	inline uint32_t get_uint32_7() const { return ___uint32_7; }
	inline uint32_t* get_address_of_uint32_7() { return &___uint32_7; }
	inline void set_uint32_7(uint32_t value)
	{
		___uint32_7 = value;
	}

	inline static int32_t get_offset_of_int64_8() { return static_cast<int32_t>(offsetof(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54, ___int64_8)); }
	inline int64_t get_int64_8() const { return ___int64_8; }
	inline int64_t* get_address_of_int64_8() { return &___int64_8; }
	inline void set_int64_8(int64_t value)
	{
		___int64_8 = value;
	}

	inline static int32_t get_offset_of_uint64_9() { return static_cast<int32_t>(offsetof(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54, ___uint64_9)); }
	inline uint64_t get_uint64_9() const { return ___uint64_9; }
	inline uint64_t* get_address_of_uint64_9() { return &___uint64_9; }
	inline void set_uint64_9(uint64_t value)
	{
		___uint64_9 = value;
	}

	inline static int32_t get_offset_of_byte0_10() { return static_cast<int32_t>(offsetof(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54, ___byte0_10)); }
	inline uint8_t get_byte0_10() const { return ___byte0_10; }
	inline uint8_t* get_address_of_byte0_10() { return &___byte0_10; }
	inline void set_byte0_10(uint8_t value)
	{
		___byte0_10 = value;
	}

	inline static int32_t get_offset_of_byte1_11() { return static_cast<int32_t>(offsetof(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54, ___byte1_11)); }
	inline uint8_t get_byte1_11() const { return ___byte1_11; }
	inline uint8_t* get_address_of_byte1_11() { return &___byte1_11; }
	inline void set_byte1_11(uint8_t value)
	{
		___byte1_11 = value;
	}

	inline static int32_t get_offset_of_byte2_12() { return static_cast<int32_t>(offsetof(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54, ___byte2_12)); }
	inline uint8_t get_byte2_12() const { return ___byte2_12; }
	inline uint8_t* get_address_of_byte2_12() { return &___byte2_12; }
	inline void set_byte2_12(uint8_t value)
	{
		___byte2_12 = value;
	}

	inline static int32_t get_offset_of_byte3_13() { return static_cast<int32_t>(offsetof(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54, ___byte3_13)); }
	inline uint8_t get_byte3_13() const { return ___byte3_13; }
	inline uint8_t* get_address_of_byte3_13() { return &___byte3_13; }
	inline void set_byte3_13(uint8_t value)
	{
		___byte3_13 = value;
	}

	inline static int32_t get_offset_of_byte4_14() { return static_cast<int32_t>(offsetof(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54, ___byte4_14)); }
	inline uint8_t get_byte4_14() const { return ___byte4_14; }
	inline uint8_t* get_address_of_byte4_14() { return &___byte4_14; }
	inline void set_byte4_14(uint8_t value)
	{
		___byte4_14 = value;
	}

	inline static int32_t get_offset_of_byte5_15() { return static_cast<int32_t>(offsetof(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54, ___byte5_15)); }
	inline uint8_t get_byte5_15() const { return ___byte5_15; }
	inline uint8_t* get_address_of_byte5_15() { return &___byte5_15; }
	inline void set_byte5_15(uint8_t value)
	{
		___byte5_15 = value;
	}

	inline static int32_t get_offset_of_byte6_16() { return static_cast<int32_t>(offsetof(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54, ___byte6_16)); }
	inline uint8_t get_byte6_16() const { return ___byte6_16; }
	inline uint8_t* get_address_of_byte6_16() { return &___byte6_16; }
	inline void set_byte6_16(uint8_t value)
	{
		___byte6_16 = value;
	}

	inline static int32_t get_offset_of_byte7_17() { return static_cast<int32_t>(offsetof(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54, ___byte7_17)); }
	inline uint8_t get_byte7_17() const { return ___byte7_17; }
	inline uint8_t* get_address_of_byte7_17() { return &___byte7_17; }
	inline void set_byte7_17(uint8_t value)
	{
		___byte7_17 = value;
	}

	inline static int32_t get_offset_of_uint16_B_18() { return static_cast<int32_t>(offsetof(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54, ___uint16_B_18)); }
	inline uint32_t get_uint16_B_18() const { return ___uint16_B_18; }
	inline uint32_t* get_address_of_uint16_B_18() { return &___uint16_B_18; }
	inline void set_uint16_B_18(uint32_t value)
	{
		___uint16_B_18 = value;
	}
};

// Native definition for P/Invoke marshalling of emotitron.Compression.ByteConverter
struct ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54_marshaled_pinvoke
{
	union
	{
		#pragma pack(push, tp, 1)
		struct
		{
			float ___float32_0;
		};
		#pragma pack(pop, tp)
		struct
		{
			float ___float32_0_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			double ___float64_1;
		};
		#pragma pack(pop, tp)
		struct
		{
			double ___float64_1_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			int8_t ___int8_2;
		};
		#pragma pack(pop, tp)
		struct
		{
			int8_t ___int8_2_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			int16_t ___int16_3;
		};
		#pragma pack(pop, tp)
		struct
		{
			int16_t ___int16_3_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			uint16_t ___uint16_4;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint16_t ___uint16_4_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			uint8_t ___character_5;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint8_t ___character_5_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			int32_t ___int32_6;
		};
		#pragma pack(pop, tp)
		struct
		{
			int32_t ___int32_6_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			uint32_t ___uint32_7;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint32_t ___uint32_7_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			int64_t ___int64_8;
		};
		#pragma pack(pop, tp)
		struct
		{
			int64_t ___int64_8_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			uint64_t ___uint64_9;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint64_t ___uint64_9_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			uint8_t ___byte0_10;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint8_t ___byte0_10_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte1_11_OffsetPadding[1];
			uint8_t ___byte1_11;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte1_11_OffsetPadding_forAlignmentOnly[1];
			uint8_t ___byte1_11_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte2_12_OffsetPadding[2];
			uint8_t ___byte2_12;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte2_12_OffsetPadding_forAlignmentOnly[2];
			uint8_t ___byte2_12_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte3_13_OffsetPadding[3];
			uint8_t ___byte3_13;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte3_13_OffsetPadding_forAlignmentOnly[3];
			uint8_t ___byte3_13_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte4_14_OffsetPadding[4];
			uint8_t ___byte4_14;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte4_14_OffsetPadding_forAlignmentOnly[4];
			uint8_t ___byte4_14_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte5_15_OffsetPadding[5];
			uint8_t ___byte5_15;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte5_15_OffsetPadding_forAlignmentOnly[5];
			uint8_t ___byte5_15_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte6_16_OffsetPadding[6];
			uint8_t ___byte6_16;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte6_16_OffsetPadding_forAlignmentOnly[6];
			uint8_t ___byte6_16_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte7_17_OffsetPadding[7];
			uint8_t ___byte7_17;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte7_17_OffsetPadding_forAlignmentOnly[7];
			uint8_t ___byte7_17_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___uint16_B_18_OffsetPadding[4];
			uint32_t ___uint16_B_18;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___uint16_B_18_OffsetPadding_forAlignmentOnly[4];
			uint32_t ___uint16_B_18_forAlignmentOnly;
		};
	};
};
// Native definition for COM marshalling of emotitron.Compression.ByteConverter
struct ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54_marshaled_com
{
	union
	{
		#pragma pack(push, tp, 1)
		struct
		{
			float ___float32_0;
		};
		#pragma pack(pop, tp)
		struct
		{
			float ___float32_0_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			double ___float64_1;
		};
		#pragma pack(pop, tp)
		struct
		{
			double ___float64_1_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			int8_t ___int8_2;
		};
		#pragma pack(pop, tp)
		struct
		{
			int8_t ___int8_2_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			int16_t ___int16_3;
		};
		#pragma pack(pop, tp)
		struct
		{
			int16_t ___int16_3_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			uint16_t ___uint16_4;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint16_t ___uint16_4_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			uint8_t ___character_5;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint8_t ___character_5_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			int32_t ___int32_6;
		};
		#pragma pack(pop, tp)
		struct
		{
			int32_t ___int32_6_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			uint32_t ___uint32_7;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint32_t ___uint32_7_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			int64_t ___int64_8;
		};
		#pragma pack(pop, tp)
		struct
		{
			int64_t ___int64_8_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			uint64_t ___uint64_9;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint64_t ___uint64_9_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			uint8_t ___byte0_10;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint8_t ___byte0_10_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte1_11_OffsetPadding[1];
			uint8_t ___byte1_11;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte1_11_OffsetPadding_forAlignmentOnly[1];
			uint8_t ___byte1_11_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte2_12_OffsetPadding[2];
			uint8_t ___byte2_12;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte2_12_OffsetPadding_forAlignmentOnly[2];
			uint8_t ___byte2_12_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte3_13_OffsetPadding[3];
			uint8_t ___byte3_13;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte3_13_OffsetPadding_forAlignmentOnly[3];
			uint8_t ___byte3_13_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte4_14_OffsetPadding[4];
			uint8_t ___byte4_14;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte4_14_OffsetPadding_forAlignmentOnly[4];
			uint8_t ___byte4_14_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte5_15_OffsetPadding[5];
			uint8_t ___byte5_15;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte5_15_OffsetPadding_forAlignmentOnly[5];
			uint8_t ___byte5_15_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte6_16_OffsetPadding[6];
			uint8_t ___byte6_16;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte6_16_OffsetPadding_forAlignmentOnly[6];
			uint8_t ___byte6_16_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte7_17_OffsetPadding[7];
			uint8_t ___byte7_17;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte7_17_OffsetPadding_forAlignmentOnly[7];
			uint8_t ___byte7_17_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___uint16_B_18_OffsetPadding[4];
			uint32_t ___uint16_B_18;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___uint16_B_18_OffsetPadding_forAlignmentOnly[4];
			uint32_t ___uint16_B_18_forAlignmentOnly;
		};
	};
};
#ifdef __clang__
#pragma clang diagnostic pop
#endif



#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Winvalid-offsetof"
#pragma clang diagnostic ignored "-Wunused-variable"
#endif
#ifdef __clang__
#pragma clang diagnostic pop
#endif
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Winvalid-offsetof"
#pragma clang diagnostic ignored "-Wunused-variable"
#endif
// Conversion methods for marshalling of: emotitron.Compression.ByteConverter
IL2CPP_EXTERN_C void ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54_marshal_pinvoke(const ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54& unmarshaled, ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54_marshaled_pinvoke& marshaled)
{
	marshaled.___float32_0 = unmarshaled.get_float32_0();
	marshaled.___float64_1 = unmarshaled.get_float64_1();
	marshaled.___int8_2 = unmarshaled.get_int8_2();
	marshaled.___int16_3 = unmarshaled.get_int16_3();
	marshaled.___uint16_4 = unmarshaled.get_uint16_4();
	marshaled.___character_5 = static_cast<uint8_t>(unmarshaled.get_character_5());
	marshaled.___int32_6 = unmarshaled.get_int32_6();
	marshaled.___uint32_7 = unmarshaled.get_uint32_7();
	marshaled.___int64_8 = unmarshaled.get_int64_8();
	marshaled.___uint64_9 = unmarshaled.get_uint64_9();
	marshaled.___byte0_10 = unmarshaled.get_byte0_10();
	marshaled.___byte1_11 = unmarshaled.get_byte1_11();
	marshaled.___byte2_12 = unmarshaled.get_byte2_12();
	marshaled.___byte3_13 = unmarshaled.get_byte3_13();
	marshaled.___byte4_14 = unmarshaled.get_byte4_14();
	marshaled.___byte5_15 = unmarshaled.get_byte5_15();
	marshaled.___byte6_16 = unmarshaled.get_byte6_16();
	marshaled.___byte7_17 = unmarshaled.get_byte7_17();
	marshaled.___uint16_B_18 = unmarshaled.get_uint16_B_18();
}
IL2CPP_EXTERN_C void ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54_marshal_pinvoke_back(const ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54_marshaled_pinvoke& marshaled, ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54& unmarshaled)
{
	float unmarshaled_float32_temp_0 = 0.0f;
	unmarshaled_float32_temp_0 = marshaled.___float32_0;
	unmarshaled.set_float32_0(unmarshaled_float32_temp_0);
	double unmarshaled_float64_temp_1 = 0.0;
	unmarshaled_float64_temp_1 = marshaled.___float64_1;
	unmarshaled.set_float64_1(unmarshaled_float64_temp_1);
	int8_t unmarshaled_int8_temp_2 = 0x0;
	unmarshaled_int8_temp_2 = marshaled.___int8_2;
	unmarshaled.set_int8_2(unmarshaled_int8_temp_2);
	int16_t unmarshaled_int16_temp_3 = 0;
	unmarshaled_int16_temp_3 = marshaled.___int16_3;
	unmarshaled.set_int16_3(unmarshaled_int16_temp_3);
	uint16_t unmarshaled_uint16_temp_4 = 0;
	unmarshaled_uint16_temp_4 = marshaled.___uint16_4;
	unmarshaled.set_uint16_4(unmarshaled_uint16_temp_4);
	Il2CppChar unmarshaled_character_temp_5 = 0x0;
	unmarshaled_character_temp_5 = static_cast<Il2CppChar>(marshaled.___character_5);
	unmarshaled.set_character_5(unmarshaled_character_temp_5);
	int32_t unmarshaled_int32_temp_6 = 0;
	unmarshaled_int32_temp_6 = marshaled.___int32_6;
	unmarshaled.set_int32_6(unmarshaled_int32_temp_6);
	uint32_t unmarshaled_uint32_temp_7 = 0;
	unmarshaled_uint32_temp_7 = marshaled.___uint32_7;
	unmarshaled.set_uint32_7(unmarshaled_uint32_temp_7);
	int64_t unmarshaled_int64_temp_8 = 0;
	unmarshaled_int64_temp_8 = marshaled.___int64_8;
	unmarshaled.set_int64_8(unmarshaled_int64_temp_8);
	uint64_t unmarshaled_uint64_temp_9 = 0;
	unmarshaled_uint64_temp_9 = marshaled.___uint64_9;
	unmarshaled.set_uint64_9(unmarshaled_uint64_temp_9);
	uint8_t unmarshaled_byte0_temp_10 = 0x0;
	unmarshaled_byte0_temp_10 = marshaled.___byte0_10;
	unmarshaled.set_byte0_10(unmarshaled_byte0_temp_10);
	uint8_t unmarshaled_byte1_temp_11 = 0x0;
	unmarshaled_byte1_temp_11 = marshaled.___byte1_11;
	unmarshaled.set_byte1_11(unmarshaled_byte1_temp_11);
	uint8_t unmarshaled_byte2_temp_12 = 0x0;
	unmarshaled_byte2_temp_12 = marshaled.___byte2_12;
	unmarshaled.set_byte2_12(unmarshaled_byte2_temp_12);
	uint8_t unmarshaled_byte3_temp_13 = 0x0;
	unmarshaled_byte3_temp_13 = marshaled.___byte3_13;
	unmarshaled.set_byte3_13(unmarshaled_byte3_temp_13);
	uint8_t unmarshaled_byte4_temp_14 = 0x0;
	unmarshaled_byte4_temp_14 = marshaled.___byte4_14;
	unmarshaled.set_byte4_14(unmarshaled_byte4_temp_14);
	uint8_t unmarshaled_byte5_temp_15 = 0x0;
	unmarshaled_byte5_temp_15 = marshaled.___byte5_15;
	unmarshaled.set_byte5_15(unmarshaled_byte5_temp_15);
	uint8_t unmarshaled_byte6_temp_16 = 0x0;
	unmarshaled_byte6_temp_16 = marshaled.___byte6_16;
	unmarshaled.set_byte6_16(unmarshaled_byte6_temp_16);
	uint8_t unmarshaled_byte7_temp_17 = 0x0;
	unmarshaled_byte7_temp_17 = marshaled.___byte7_17;
	unmarshaled.set_byte7_17(unmarshaled_byte7_temp_17);
	uint32_t unmarshaled_uint16_B_temp_18 = 0;
	unmarshaled_uint16_B_temp_18 = marshaled.___uint16_B_18;
	unmarshaled.set_uint16_B_18(unmarshaled_uint16_B_temp_18);
}
// Conversion method for clean up from marshalling of: emotitron.Compression.ByteConverter
IL2CPP_EXTERN_C void ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54_marshal_pinvoke_cleanup(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54_marshaled_pinvoke& marshaled)
{
}
// Conversion methods for marshalling of: emotitron.Compression.ByteConverter
IL2CPP_EXTERN_C void ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54_marshal_com(const ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54& unmarshaled, ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54_marshaled_com& marshaled)
{
	marshaled.___float32_0 = unmarshaled.get_float32_0();
	marshaled.___float64_1 = unmarshaled.get_float64_1();
	marshaled.___int8_2 = unmarshaled.get_int8_2();
	marshaled.___int16_3 = unmarshaled.get_int16_3();
	marshaled.___uint16_4 = unmarshaled.get_uint16_4();
	marshaled.___character_5 = static_cast<uint8_t>(unmarshaled.get_character_5());
	marshaled.___int32_6 = unmarshaled.get_int32_6();
	marshaled.___uint32_7 = unmarshaled.get_uint32_7();
	marshaled.___int64_8 = unmarshaled.get_int64_8();
	marshaled.___uint64_9 = unmarshaled.get_uint64_9();
	marshaled.___byte0_10 = unmarshaled.get_byte0_10();
	marshaled.___byte1_11 = unmarshaled.get_byte1_11();
	marshaled.___byte2_12 = unmarshaled.get_byte2_12();
	marshaled.___byte3_13 = unmarshaled.get_byte3_13();
	marshaled.___byte4_14 = unmarshaled.get_byte4_14();
	marshaled.___byte5_15 = unmarshaled.get_byte5_15();
	marshaled.___byte6_16 = unmarshaled.get_byte6_16();
	marshaled.___byte7_17 = unmarshaled.get_byte7_17();
	marshaled.___uint16_B_18 = unmarshaled.get_uint16_B_18();
}
IL2CPP_EXTERN_C void ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54_marshal_com_back(const ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54_marshaled_com& marshaled, ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54& unmarshaled)
{
	float unmarshaled_float32_temp_0 = 0.0f;
	unmarshaled_float32_temp_0 = marshaled.___float32_0;
	unmarshaled.set_float32_0(unmarshaled_float32_temp_0);
	double unmarshaled_float64_temp_1 = 0.0;
	unmarshaled_float64_temp_1 = marshaled.___float64_1;
	unmarshaled.set_float64_1(unmarshaled_float64_temp_1);
	int8_t unmarshaled_int8_temp_2 = 0x0;
	unmarshaled_int8_temp_2 = marshaled.___int8_2;
	unmarshaled.set_int8_2(unmarshaled_int8_temp_2);
	int16_t unmarshaled_int16_temp_3 = 0;
	unmarshaled_int16_temp_3 = marshaled.___int16_3;
	unmarshaled.set_int16_3(unmarshaled_int16_temp_3);
	uint16_t unmarshaled_uint16_temp_4 = 0;
	unmarshaled_uint16_temp_4 = marshaled.___uint16_4;
	unmarshaled.set_uint16_4(unmarshaled_uint16_temp_4);
	Il2CppChar unmarshaled_character_temp_5 = 0x0;
	unmarshaled_character_temp_5 = static_cast<Il2CppChar>(marshaled.___character_5);
	unmarshaled.set_character_5(unmarshaled_character_temp_5);
	int32_t unmarshaled_int32_temp_6 = 0;
	unmarshaled_int32_temp_6 = marshaled.___int32_6;
	unmarshaled.set_int32_6(unmarshaled_int32_temp_6);
	uint32_t unmarshaled_uint32_temp_7 = 0;
	unmarshaled_uint32_temp_7 = marshaled.___uint32_7;
	unmarshaled.set_uint32_7(unmarshaled_uint32_temp_7);
	int64_t unmarshaled_int64_temp_8 = 0;
	unmarshaled_int64_temp_8 = marshaled.___int64_8;
	unmarshaled.set_int64_8(unmarshaled_int64_temp_8);
	uint64_t unmarshaled_uint64_temp_9 = 0;
	unmarshaled_uint64_temp_9 = marshaled.___uint64_9;
	unmarshaled.set_uint64_9(unmarshaled_uint64_temp_9);
	uint8_t unmarshaled_byte0_temp_10 = 0x0;
	unmarshaled_byte0_temp_10 = marshaled.___byte0_10;
	unmarshaled.set_byte0_10(unmarshaled_byte0_temp_10);
	uint8_t unmarshaled_byte1_temp_11 = 0x0;
	unmarshaled_byte1_temp_11 = marshaled.___byte1_11;
	unmarshaled.set_byte1_11(unmarshaled_byte1_temp_11);
	uint8_t unmarshaled_byte2_temp_12 = 0x0;
	unmarshaled_byte2_temp_12 = marshaled.___byte2_12;
	unmarshaled.set_byte2_12(unmarshaled_byte2_temp_12);
	uint8_t unmarshaled_byte3_temp_13 = 0x0;
	unmarshaled_byte3_temp_13 = marshaled.___byte3_13;
	unmarshaled.set_byte3_13(unmarshaled_byte3_temp_13);
	uint8_t unmarshaled_byte4_temp_14 = 0x0;
	unmarshaled_byte4_temp_14 = marshaled.___byte4_14;
	unmarshaled.set_byte4_14(unmarshaled_byte4_temp_14);
	uint8_t unmarshaled_byte5_temp_15 = 0x0;
	unmarshaled_byte5_temp_15 = marshaled.___byte5_15;
	unmarshaled.set_byte5_15(unmarshaled_byte5_temp_15);
	uint8_t unmarshaled_byte6_temp_16 = 0x0;
	unmarshaled_byte6_temp_16 = marshaled.___byte6_16;
	unmarshaled.set_byte6_16(unmarshaled_byte6_temp_16);
	uint8_t unmarshaled_byte7_temp_17 = 0x0;
	unmarshaled_byte7_temp_17 = marshaled.___byte7_17;
	unmarshaled.set_byte7_17(unmarshaled_byte7_temp_17);
	uint32_t unmarshaled_uint16_B_temp_18 = 0;
	unmarshaled_uint16_B_temp_18 = marshaled.___uint16_B_18;
	unmarshaled.set_uint16_B_18(unmarshaled_uint16_B_temp_18);
}
// Conversion method for clean up from marshalling of: emotitron.Compression.ByteConverter
IL2CPP_EXTERN_C void ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54_marshal_com_cleanup(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54_marshaled_com& marshaled)
{
}
// emotitron.Compression.ByteConverter emotitron.Compression.ByteConverter::op_Implicit(System.UInt32)
IL2CPP_EXTERN_C IL2CPP_METHOD_ATTR ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54  ByteConverter_op_Implicit_m82F307883E3EC5CC5B1C647E80FE5B0B3815DB78 (uint32_t ___val0, const RuntimeMethod* method)
{
	ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54  V_0;
	memset((&V_0), 0, sizeof(V_0));
	{
		il2cpp_codegen_initobj((&V_0), sizeof(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54 ));
		uint32_t L_0 = ___val0;
		(&V_0)->set_uint32_7(L_0);
		ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54  L_1 = V_0;
		return L_1;
	}
}
// emotitron.Compression.ByteConverter emotitron.Compression.ByteConverter::op_Implicit(System.Single)
IL2CPP_EXTERN_C IL2CPP_METHOD_ATTR ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54  ByteConverter_op_Implicit_m08A66AB4637B75E39DD1D8DF577E6BF1648B22C0 (float ___val0, const RuntimeMethod* method)
{
	ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54  V_0;
	memset((&V_0), 0, sizeof(V_0));
	{
		il2cpp_codegen_initobj((&V_0), sizeof(ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54 ));
		float L_0 = ___val0;
		(&V_0)->set_float32_0(L_0);
		ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54  L_1 = V_0;
		return L_1;
	}
}
// System.UInt32 emotitron.Compression.ByteConverter::op_Implicit(emotitron.Compression.ByteConverter)
IL2CPP_EXTERN_C IL2CPP_METHOD_ATTR uint32_t ByteConverter_op_Implicit_m0E32D5850DEC82E53E83AAC0A75E78850BF5AA93 (ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54  ___bc0, const RuntimeMethod* method)
{
	{
		ByteConverter_tD6329DB60F8F57997E22F9AA2D1F3F38E2472C54  L_0 = ___bc0;
		uint32_t L_1 = L_0.get_uint32_7();
		return L_1;
	}
}
#ifdef __clang__
#pragma clang diagnostic pop
#endif
